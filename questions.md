== Список вопросов к зачету

1. В чем разница `=` и `:=` в присвоении переменной значения?
2. На что влияет регистр первой буквы в имени переменной/типа/функции (`Hello` vs `hello`)?
3. Чем инициализируется вновь созданная переменная, если явно не указывать значение (`var x int`)?
4. В какой момент инициализируются глобальные переменные?
5. Как будет вести себя краткий синтаксис инициализации (`:=`) в конструкции `i, j := 1, 2` в зависимости от статуса "объявленности" переменных `i` и `j` в коде выше?
6. Что такое указатель и какие операции с ним можно произвести?
7. Как передаются агрументы в функцию (по значению, по ссылке)? Всегда ли?
8. Что делает функция `new`?
9. Корректно ли возвращать из функции указатель на локальную переменную? Почему?
10. Что такое escape analysis?
11. Для чего вместо имени переменной иногда используют `_`? Приведите примеры.
12. Чем особенна функция `func init() {...}`? Когда она вызывается?
13. Разрешены ли циклические импорты пакетов? Если да, то как разрешается последовательность инициализации?
14. Что такое область видимости переменной?
15. Как работает область видимости переменной при наличии вложенных областей?
16. В чем особенность `:=` при перекрытии (shadow) имен переменных во вложенной области видимости?
17. Какие значения будут принимать переменные `i` и `j` в цикце `for i, j := range "Hello, Мир!"`? Почему?
18. Что такое `iota`? Для чего используется?
19. Как устроен внутри слайс? Как узнать его длину и емкость?
20. При передачу внутрь функции слайс передается по ссылке или по значению? Почему?
21. Как работает функция `append`?
22. Как работает сабслайсинг (оператор `[:]`)?
23. Валидно ли использовать неинициализированные slice и map (т.е. равные `nil`)?
24. Как с помощью функции `append` вставить элемент в середину слайса?
25. Какая структура данных (с т.з. алгоритмов) лежит в основе `map`?
26. Как можно инициализировать `map`?
27. Что произойдет, если в `map` обратиться по несуществующему (в нем) ключу?
28. Как проверить, что ключа нет в `map`?
29. Можно ли взять адрес от элемента, лежащего в `map`?
30. Какой порядок элементов гарантируется при итерации по `map` через `for-range`?
31. На что влияет регистр первой буквы поля или метода в структуре?
32. Что такое встраивание (embedding) в структурах?
33. Что такое именованные возвращаемые значения? Как их использовать?
34. Что выведет код ниже?
```go
func main() {
	var x = 0
	func() {
		x = 42
	}()
	fmt.Println(x)
}
```
35. Какой тип используется для возврата ошибок? Чем он является?
36. Для чего ипользуются `errors.Is` и `errors.As`? В чем между ними разница?
37. Что такое `defer`? Приведите сценарий использования?
38. В каком порядке вызываются объявленные в `defer` функции при наличии нескольких объявлений?
39. Вызывается ли `defer` при панике?
40. В какой момент вычисляются аргументы функции, вызываемой в `defer`?
41. Что такое `panic`? Что происходит в программе, когда вылетает паника?
42. Как остановить выполнение паники? Что произойдет, если этого не сделать?
43. В чем разница (в идеологии) между паниками и ошибками?
44. В каком месте программы осмысленно использовать функцию `recover`?
45. Что такое `receiver` в методе? В чем разница между `pointer receiver` и `value receiver`?
46. Что выведется в следующем коде? Почему?
```go
type Foo struct {
}

func (f *Foo) Bar() {
	fmt.Println("Hello!")
}

func main() {
	var m = make(map[int]Foo)
	m[1] = Foo{}
	m[1].Bar()
}
```
47. Можно ли вызвать метод на `nil` указателе какого-либо типа? Что произойдет?
48. Что такое интерфейс (interface)? Как он устроен?
49. Как указать в типе, что данный тип удовлетворяет некоторому интерфейсу?
50. В чем разница между nil-интерфейсами и интерфейсами, содержащими nil?
51. Как проверить, какой тип находится за интерфейсом (при условии, что мы предполагаем что там может быть)?
52. Что такое `type switch`? В каких сценариях может использоваться?
53. Что такое горутина (`goroutine`)? Как запустить горутину?
54. Как горутины связаны с потоками ОС? Как работает шедулер?
55. Что произойдет, если функция `main` завершит исполнение раньше, чем закончится выполянться какая-либо другая горутина?
55. Как дождаться выполнения горутины?
56. Как вручную задать количество потоков ОС в программе?
57. Что такое канал (`chan`)? Какие каналы бывают?
58. Можно ли читать и писать в/из закрытого канала?
59. Как создать канал с размером буфера 10?
60. Почему операции записи/чтения в/из канала могут блокироваться? В каких ситуациях блокировки не будет?
61. Как сделать неблокирующее чтение из канала в любом исходе (т.е. даже если в канале ничего нет)?
62. Что такое состояние гонки (race condition)? Приведите пример.
63. Для чего используется мьютекс (`sync.Mutex`)? Каков сценарий использования?
64. В чем разница между `sync.Mutex` и `sync.RWMutex`?
65. Для чего используется `sync.Once`? Приведите сценарий использования.
66. Как можно проверить (например, тестами), что в программе нет состояния гонки (race condition)?
67. В чем разница между blackbox- и whitebox-тестами? Как в Go можно явно сделать blackbox-тесты (технически запретить доступаться до неэкспортируемых сущностей)?
68. Что такое `generics`? Приведите пример, когда дженерики упрощают написание кода.
